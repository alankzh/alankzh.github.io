---
layout: post
title:  "谈谈一致性(consistency)"
date:   2019-08-11 9:29
categories: 分布式
tags: 编程 Java C++
---
* content
{:toc}

谈到一致性(consistency)，能联想到的场景有以下:
<br/>
- Associated_1. 数据库事务，ACID中的一致性。
- Associated_2. 分布式系统的一致性。包括节点之间的状态一致性；数据库与缓存之间的一致性等。
- Associated_3. 多核CPU，缓存、内存一致性。

由于一致性在计算机行业内涉及的广泛，所以我很难给出一个涵盖不同场景的精确定义。
<br/><br/>
比较宽泛的定义是，一致性 ≈ 正确性 = 与期望一致。
<br/><br/>
正确，是相对于错误而言的。一个系统，是由状态和一些导致状态转移的操作组成的。
如果系统的状态与期望一致，那么人们认为这个系统是正确的。
<br/><br/>
不同场景有不同的期望，所以有不同的一致性。
<br/><br/>
## Q1: 电商超卖
电商中，订单和库存的状态，操作产生的新状态，如何才能与与人们的期望是一致的呢？
<br/>
如果订单的状态先被改变为'下单'，若后续的库存状态改变失败，则导致超卖；
<br/>
如果库存状态先被改变为number - 1，若后续的下订单不成功，那么导致少卖。
<br/><br/>
两种情况都是不符合人们的期望的，不正确，产生了问题。对这个业务，我们期望获得一致性。
<br/><br/>

## ACID
如果订单和库存都是单个服务、单个数据库来保障的，那么可以依赖具有ACID特性的数据库来满足业务一致性。例如DB2、MySQL、Oracle、PostgreSQL等。
<br/>

一个ACID是一个事物单元，它需要满足：
- A: Atomicity，原子性
- C: Consistency，一致性
- I: Isolation，隔离性
- D: Durability，持久性

<br/>
事物(T1)：用户购买两本《C++ Primer》，同时扣除库存容量2。
<br/><br/>
事物(T2)：另一用户购买一本《C++ primer》，扣除库存容量1。
<br/><br/>
原子性表明数据库会明确的从一个状态到另一个状态，不会有中间状态。不管T1期间发生什么，不会发生用户有了一个两本书的订单而库存未被扣除的情况。
<br/><br/>
隔离性确保如果T1和T2同时发生，那么库存将被扣除3，而不是T1和T2之间存在抹除。
<br/><br/>

持久性确保如果T1刚刚提交，数据库崩溃，T1不会消失。
<br/><br/>

一致性与原子性和隔离性相关。订单和库存没有生成或灭失。
<br/><br/>

这里的一致性是数据库自身事物的一致性，对于Q1，业务上利用的是数据库提供的原子性和隔离性来达成服务方面的一致性。
<br/><br/>

## CAP

互联网项目大多数是大规模、高并发的，必须使用拆分的理念，对高并发的压力“分而治之，大而化小”。对于Q1，有时相关的表无法放到同一个数据库中，并且订单服务和库存服务可能是拆分的。
<br/><br/>
分布式系统的CAP理论包含了如下三个元素:
- C: Consistency,一致性。在分布式系统中的所有数据备份，在同一时刻具有同样的值，所有节点在同一时刻读取的数据都是最新的数据副本。
- A: Availability，可用性。完全的可用性是指在任何故障模型下，服务都会在有限的时间内处理完成并进行响应。
- P：Partition tolerance，分区容忍性。尽管网络上有部分消息丢失，但系统仍让可继续工作。

<br/>
CAP理论指出，任何分布式系统只可同时满足以上两点，无法三者兼顾。而分布式的服务化系统，都要满足分区容忍性，那么需要权衡的即为一致性和可用性。这里我将CAP理论提出的一致性称为强一致性。后续我们会看到为了可用性，我们会牺牲强一致性，只要求分布式系统满足层度较弱的一致性。

回顾下具有ACID的关系型数据库。它不具备分区容忍性，但是它具有强一致性和可用性。
<br/><br/>
不过数据库在一致性和可用性之间也存在着权衡。它一般定义四个隔离级别:
- Serializable
- Repeatable read
- Read committed
- Read uncommitted

不同的隔离级别具有不同层度的一致性、可用性。隔离级别越低，可用性越高。相应的，一致性也越弱。
参考文章: [Highly Available Transactions](http://www.vldb.org/pvldb/vol7/p181-bailis.pdf)

数据库为了提供可用性，不但提供了可选的隔离级别，内部也做了各种优化，有多种类型、多种粒度的锁。一些数据库还使用多版本控制的机制。两种各有利弊，一个悲观锁、一个乐观锁。关于多版本控制，可参见文章: [PostgreSQL MVCC](http://momjian.us/main/writings/pgsql/mvcc.pdf)
<br/><br/>
既然数据库为了可用性做出了对一致性的牺牲。那么分布式系统一样可以对一致性进行牺牲。所需慎重考虑的是，这种牺牲是否在一定层度之内，即分布式系统没有满足强一致性，但也满足了一定层度的一致性。
<br/><br/>

## Consistency Model

为了不同的性能(可用性)、正确性的需求(一致性)，人们在研究多核CPU并发内存访问时，提出了各种不同的[内存一致性模型](https://wc.yooooo.us/wiki/%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B)。
<br/><br/>
这些内存一致性模型包含:
- Linearizability: 线性一致性。任何对一个内存位置X的读操作，将返回最近一次对该内存位置的写操作所写入的值。
- Sequential consistency: 顺序一致性。所有的处理器以相同的顺序看到所有的修改，读操作未必能及时得到此前其他处理器对同一数据的写更新，但是各处理器读到的该数据的不同值的顺序是一致的。
- Causal consistency： 因果一致性。与顺序一致性相比，只对有因果关系的事件有顺序要求。
- ……

<br/>
这些模型给出操作导致状态变化的规则，如果系统的操作历史在任何情况都符合此规则，那么就满足它们对外提供的一致性。
<br/><br/>
从线性一致性，到顺序一致性，到因果一致性，系统提供的一致性的层度逐渐降低。
<br/><br/>
它们很容易推广到其他业务情形，我们只要证明系统的操作符合一致性模型的规则，那么就可以在数学上证明系统能对外提供何种级别的一致性。
<br/><br/>
具有ACID的关系型数据库，如果隔离级别为Serializable，显然，这个系统符合线性一致性(Linearizability)，这也是CAP理论中定义的强一致性。
<br/><br/>
有些数学出身的朋友最讨厌的词就是‘显然’，所幸，这篇文章给出了如何检验是否为线性一致性模型的方法:

[Linearizability: A Correctness Condition for Concurrent Objects](https://alankzh-blog-files.oss-cn-beijing.aliyuncs.com/p463-herlihy.pdf)
<br/><br/>

Zookeeper一直被认为是CP的，它的[文档](https://zookeeper.apache.org/doc/r3.4.14/zookeeperOver.html#Guarantees)也声称自己是符合顺序一致性模型的。不过它的读是否保证有序，还待后续给出确定性的说明。
<br/><br/>
[微信朋友圈技术上](https://alankzh-blog-files.oss-cn-beijing.aliyuncs.com/%E7%A7%BB%E5%8A%A8%E5%8C%96%E6%9C%BA%E4%BC%9A_%E9%99%88%E6%98%8E_%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E6%8A%80%E6%9C%AF%E4%B9%8B%E9%81%93.pdf)保证评论符合因果一致性。先看到了评论，才能看到对此评论的回复。每条评论都有一个唯一递增id，确保去重和因果有序。
<br/><br/>
## BASE

BASE思想是解决分布式系统的一致性和可用性不可兼得的利器，它包含三个元素:
- BA: Basically Available, 基本可用。
- S： Soft State，软状态，状态可以在一段时间内不同步。
- E： Eventually Consistent，最终一致，在一定的时间窗口，最终数据达到一致。

弱状态是实现BASE思想的方法，基本可用和最终一致是目标.系统在处理请求的过程中可以存在短暂的不一致，在短暂不一致的时间窗口内，请求处理处于临时状态中。即系统每一步操作时，通过记录临时状态，在系统出现故障时可从这些中间状态继续处理未完成的请求，或是回退。从而达到最终一致性。
<br/><br/>
[最终一致性](https://en.wikipedia.org/wiki/Eventual_consistency)是一个弱一致性模型。我暂时没有找到数学上如何证明系统符合这个模型，也没有找到数据同步的时间窗口应该是何种范围。
<br/><br/>
但一些做法，足以不严格的认为系统‘显然’能达到最终一致性。
<br/><br/>
## Q2: 同步回调超时
服务A调用服务B超时，服务A可以明确得到超时反馈，但是无法确定服务B是否已经完成了预设的功能。例如打款操作，调用打款服务B超时，服务A不知是否应该扣除用户账户的余额。
<br/><br/>
## 人工干预
解决Q2非常简单，当打款的客户来投诉我们的时候，技术人员通过服务的流水号、订单号查询数据库，然后进行数据库变更，即可解决。
<br/><br/>
![扔鸡蛋.jpg](https://alankzh-blog-imgs.oss-cn-beijing.aliyuncs.com/timg.jpg)
<br/><br/>
先别着急扔鸡蛋, 如果存在这么一个理想人，无时无刻都在巡查系统，并高效而不知疲倦的纠正不一致的状态，显然，这个系统是最终一致的。
<br/><br/>
显然，这么一个理想人是不存在的，现实是，只存在血肉之躯的程序员。但人工干预确实是系统达成最终一致性的功能环节之一。后续的我们所有做法，都是为了削减理想人