---
layout: post
title:  "谈谈一致性(consistency)"
date:   2019-08-11 9:29
categories: 分布式
tags: 编程 Java C++
---
* content
{:toc}

谈到一致性(consistency)，能联想到的场景有以下:
<br/>
- Associated_1. 数据库事务，ACID中的一致性。
- Associated_2. 分布式系统的一致性。包括节点之间的状态一致性；数据库与缓存之间的一致性等。
- Associated_3. 多核CPU，缓存、内存一致性。

由于一致性在计算机行业内涉及的广泛，所以我很难给出一个涵盖不同场景的精确定义。
<br/><br/>
比较宽泛的定义是，一致性 ≈ 正确性 = 与期望一致。
<br/><br/>
正确，是相对于错误而言的。一个系统，是由状态和一些导致状态转移的操作组成的。
如果系统的状态与期望一致，那么人们认为这个系统是正确的。
<br/><br/>
不同场景有不同的期望，所以有不同的一致性。
<br/><br/>
## Q1: 电商超卖
电商中，订单和库存的状态，操作产生的新状态，如何才能与与人们的期望是一致的呢？
<br/>
如果订单的状态先被改变为'下单'，若后续的库存状态改变失败，则导致超卖；
<br/>
如果库存状态先被改变为number - 1，若后续的下订单不成功，那么导致少卖。
<br/><br/>
两种情况都是不符合人们的期望的，不正确，产生了问题。对这个业务，我们期望获得一致性。
<br/><br/>

## ACID
如果订单和库存都是单个服务、单个数据库来保障的，那么可以依赖具有ACID特性的数据库来满足业务一致性。例如DB2、MySQL、Oracle、PostgreSQL等。
<br/>

一个ACID是一个事物单元，它需要满足：
- A: Atomicity，原子性
- C: Consistency，一致性
- I: Isolation，隔离性
- D: Durability，持久性

<br/>
事物(T1)：用户购买两本《C++ Primer》，同时扣除库存容量2。
<br/><br/>
事物(T2)：另一用户购买一本《C++ primer》，扣除库存容量1。
<br/><br/>
原子性表明数据库会明确的从一个状态到另一个状态，不会有中间状态。不管T1期间发生什么，不会发生用户有了一个两本书的订单而库存未被扣除的情况。
<br/><br/>
隔离性确保如果T1和T2同时发生，那么库存将被扣除3，而不是T1和T2之间存在抹除。
<br/><br/>

持久性确保如果T1刚刚提交，数据库崩溃，T1不会消失。
<br/><br/>

一致性与原子性和隔离性相关。订单和库存没有生成或灭失。
<br/><br/>

这里的一致性是数据库自身事物的一致性，对于Q1，业务上利用的是数据库提供的原子性和隔离性来达成服务方面的一致性。
<br/><br/>

## CAP

互联网项目大多数是大规模、高并发的，必须使用拆分的理念，对高并发的压力“分而治之，大而化小”。对于Q1，有时相关的表无法放到同一个数据库中，并且订单服务和库存服务可能是拆分的。
<br/><br/>
分布式系统的CAP理论包含了如下三个元素:
- C: Consistency,一致性。在分布式系统中的所有数据备份，在同一时刻具有同样的值，所有节点在同一时刻读取的数据都是最新的数据副本。
- A: Availability，可用性。完全的可用性是指在任何故障模型下，服务都会在有限的时间内处理完成并进行响应。
- P：Partition tolerance，分区容忍性。尽管网络上有部分消息丢失，但系统仍可继续工作。

<br/>
CAP理论指出，任何分布式系统只可同时满足以上两点，无法三者兼顾。而分布式的服务化系统，都要满足分区容忍性，那么需要权衡的即为一致性和可用性。这里我将CAP理论提出的一致性称为强一致性。后续我们会看到为了可用性，我们会牺牲强一致性，只要求分布式系统满足层度较弱的一致性。

回顾下具有ACID的关系型数据库。它不具备分区容忍性，但是它具有强一致性和可用性。
<br/><br/>
不过数据库在一致性和可用性之间也存在着权衡。它一般定义四个隔离级别:
- Serializable
- Repeatable read
- Read committed
- Read uncommitted

不同的隔离级别具有不同层度的一致性、可用性。隔离级别越低，可用性越高。相应的，一致性也越弱。
参考文章: [Highly Available Transactions](http://www.vldb.org/pvldb/vol7/p181-bailis.pdf)

数据库为了提供可用性，不但提供了可选的隔离级别，内部也做了各种优化，有多种类型、多种粒度的锁。一些数据库还使用多版本控制的机制。两种各有利弊，一个悲观锁、一个乐观锁。关于多版本控制，可参见文章: [PostgreSQL MVCC](http://momjian.us/main/writings/pgsql/mvcc.pdf)
<br/><br/>
既然数据库为了可用性做出了对一致性的牺牲。那么分布式系统一样可以对一致性进行牺牲。所需慎重考虑的是，这种牺牲是否在一定层度之内，即分布式系统没有满足强一致性，但也满足了一定层度的一致性。
<br/><br/>

## Consistency Model

为了不同的性能(可用性)、正确性的需求(一致性)，人们在研究多核CPU并发内存访问时，提出了各种不同的[内存一致性模型](https://wc.yooooo.us/wiki/%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B)。
<br/><br/>
这些内存一致性模型包含:
- Linearizability: 线性一致性。任何对一个内存位置X的读操作，将返回最近一次对该内存位置的写操作所写入的值。
- Sequential consistency: 顺序一致性。所有的处理器以相同的顺序看到所有的修改，读操作未必能及时得到此前其他处理器对同一数据的写更新，但是各处理器读到的该数据的不同值的顺序是一致的。
- Causal consistency： 因果一致性。与顺序一致性相比，只对有因果关系的事件有顺序要求。
- ……

<br/>
这些模型给出操作导致状态变化的规则，如果系统的操作历史在任何情况都符合此规则，那么就满足它们对外提供的一致性。
<br/><br/>
从线性一致性，到顺序一致性，到因果一致性，系统提供的一致性的层度逐渐降低。
<br/><br/>
它们很容易推广到其他业务情形，我们只要证明系统的操作符合一致性模型的规则，那么就可以在数学上证明系统能对外提供何种级别的一致性。
<br/><br/>
具有ACID的关系型数据库，如果隔离级别为Serializable，显然，这个系统符合线性一致性(Linearizability)，这也是CAP理论中定义的强一致性。
<br/><br/>
有些数学出身的朋友最讨厌的词就是‘显然’，所幸，这篇文章给出了如何检验是否为线性一致性模型的方法:

[Linearizability: A Correctness Condition for Concurrent Objects](https://alankzh-blog-files.oss-cn-beijing.aliyuncs.com/p463-herlihy.pdf)
<br/><br/>

Zookeeper一直被认为是CP的，它的[文档](https://zookeeper.apache.org/doc/r3.4.14/zookeeperOver.html#Guarantees)也声称自己是符合顺序一致性模型的。不过它的读是否保证有序，还待后续给出确定性的说明。
<br/><br/>
[微信朋友圈技术上](https://alankzh-blog-files.oss-cn-beijing.aliyuncs.com/%E7%A7%BB%E5%8A%A8%E5%8C%96%E6%9C%BA%E4%BC%9A_%E9%99%88%E6%98%8E_%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E6%8A%80%E6%9C%AF%E4%B9%8B%E9%81%93.pdf)保证评论符合因果一致性。先看到了评论，才能看到对此评论的回复。每条评论都有一个唯一递增id，确保去重和因果有序。
<br/><br/>
## BASE

BASE思想是解决分布式系统的一致性和可用性不可兼得的利器，它包含三个元素:
- BA: Basically Available, 基本可用。
- S： Soft State，软状态，状态可以在一段时间内不同步。
- E： Eventually Consistent，最终一致，在一定的时间窗口，最终数据达到一致。

弱状态是实现BASE思想的方法，基本可用和最终一致是目标.系统在处理请求的过程中可以存在短暂的不一致，在短暂不一致的时间窗口内，请求处理处于临时状态中。即系统每一步操作时，通过记录临时状态，在系统出现故障时可从这些中间状态继续处理未完成的请求，或是回退。从而达到最终一致性。
<br/><br/>
[最终一致性](https://en.wikipedia.org/wiki/Eventual_consistency)是一个弱一致性模型。我暂时没有找到数学上如何证明系统符合这个模型，也没有找到数据同步的时间窗口应该是何种范围。
<br/><br/>
但一些做法，足以不严格的认为系统‘显然’能达到最终一致性。
<br/><br/>
## Q2: 同步回调超时
服务A调用服务B超时，服务A可以明确得到超时反馈，但是无法确定服务B是否已经完成了预设的功能。例如打款操作，调用打款服务B超时，服务A不知是否应该扣除用户账户的余额。
<br/><br/>
## 人工干预
解决Q2非常简单，当打款的客户来投诉我们的时候，技术人员通过服务的流水号、订单号查询数据库，然后进行数据库变更，即可解决。
<br/><br/>
![扔鸡蛋.jpg](https://alankzh-blog-imgs.oss-cn-beijing.aliyuncs.com/timg.jpg)
<br/><br/>
先别着急扔鸡蛋, 如果存在这么一个理想人，无时无刻都在巡查系统，并高效而不知疲倦的纠正不一致的状态，显然，这个系统是最终一致的。
<br/><br/>
显然，这么一个理想人是不存在的，现实是，只存在熬夜秃头的程序员。但人工干预确实是系统达成最终一致性的功能环节之一。后续的我们所有做法，都是为了削减理想人的工作量，以让肉体凡胎的程序员也能胜任本由理想人胜任的工作。
<br/><br/>
用程序来减轻人类的工作量，这正是programmer所擅长的！
<br/><br/>
## 分布式一致性协议

保证状态变化操作的成功率，能显著减少理想人的工作量。一些分布式协议是提高操作成功率的好做法。
<br/>
### (1). 两阶段提交协议
状态变更会经历准备、正式提交两个阶段。
<br/><br/>
![两阶段提交协议](https://alankzh-blog-imgs.oss-cn-beijing.aliyuncs.com/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE.png)
<br/><br/>
- 准备: 协调者向参与者发起指令，参与者如果可以完成状态变更，则锁定资源、写redo、undo日志、执行操作，但是并不提交。
- 提交: 若每个参与者都返回成功，则协调者向参与者发起提交。任何一个参与者返回失败，则发起中止指令，让参与者取消变更，执行undo日志，释放资源。

两阶段提交协议可以在分布式系统中解决Q1，协调者同时向订单服务和库存服务发起准备指令，此时资源即被锁定，不会出现不一致。

### (2). 三阶段提交协议

三阶段提交协议相比两阶段提交协议增加了询问阶段，若参与者无法执行操作，则会更快暴露出来。
<br/><br/>
![三阶段提交协议](https://alankzh-blog-imgs.oss-cn-beijing.aliyuncs.com/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE.png)
<br/><br/>
同时，三阶段提交协议在准备阶段以后，若出现同步调用超时，则协调者和参与者都会继续提交，默认为成功。
<br/><br/>

三阶段提交协议一样能解决Q1，但是对于Q2，同步调用超时，两阶段提交协议、三阶段提交协议仍然无法保证一致。需要人工干预。
<br/><br/>
### TCC协议
TCC协议将一个任务拆分为Try、Confirm、Cancel三个步骤。
<br/><br/>
![TCC协议](https://alankzh-blog-imgs.oss-cn-beijing.aliyuncs.com/TCC.png)
<br/><br/>
它仍然是一个两阶段提交协议，但具有一定自我修复能力。参与者出现问题时，可以通过Cancel步骤自我修复。
<br/><br/>
TCC协议的修复能力有限，如果Cancel指令一些参与者没有收到，则出现不一致情况。
<br/><br/>
总之，两阶段、三阶段、TCC协议，能解决很多一致性问题，减轻人工干预的工作量。但是需要参与者实现各个阶段的状态，实现复杂，性能堪忧。
<br/><br/>
## 更有效、简单的模式，三板斧: 定时查询、定期校对、补偿。
实现最终一致性，有一些更简单，性能更高的做法。
<br/><br/>
### (1). 定时查询
对于Q2同步调用超时。账务系统A服务转账时，先利用关系型数据库的ACID，将转账金额从个人账户扣除、冻结账户增加。此时向B服务发送转账请求。若调用超时，则定时任务发现位于冻结账户表的未完成交易，再次查询B服务。若转账已经成功，则A服务可以将交易日志状态设为成功，冻结账户金额扣除。若转账失败，则A服务可以利用关系型数据的ACID，将转账金额从冻结账户回退到个人账户。
<br/><br/>
查询操作依赖于每个服务操作都有一个唯一id标识，一些算法可以保证即使是分布式系统中，多个节点仍然能独立的生成全局唯一id。例如facebook的snowflake，以及原创发号器Vesta。
<br/><br/>
### (2). 定期校对
定期校对相比定是查询，是批量的，多应用于金融系统中。包括商户交易对账、系统间一致性对账、现金对账、账务对账、手续费对账等。
<br/><br/>
### (3). 补偿
当通过定是查询、定期校对，发现了系统间的不一致时，则需要补偿操作来弥补不一致。
- 自动恢复: 程序根据不一致的情形，选择完成未完成的操作，或者是取消已经进行的操作。例如(1).定时查询中所举示例。
- 运营恢复: 若设计时考虑到了不一致的场景，而这些场景程序无法自动恢复，则可以通过管理系统中的预开发功能，由运营人员操作补偿。
- 人工干预: 如果无法自动恢复和运营恢复，最后还是要程序员上场，变更数据库或者代码。这是最后的保证。

通过这三板斧，可以解决Q1、Q2，并且实现简单。而且三板斧的威力不止如此。不仅适用于同步调用，异步调用的情况也可以推广。
<br/><br/>

## Q3. 掉单
仍然是打款情形，服务A转账到服务B，服务B回复成功，但是由于某种意外情形，服务B的订单并未入库。此时服务A存在订单，服务B不存在。产生严重的不一致。
<br/><br/>

最后两阶段、三阶段、TCC协议无力解决Q3，而三板斧中的定期校对可以对这种情形进行止损。
<br/><br/>


